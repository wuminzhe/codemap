// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Path from "path";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as TreeSitter from "tree-sitter";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";
import * as TreeSitterPython from "tree-sitter-python";
import * as TreeSitterJavascript from "tree-sitter-javascript";

function getLanguageName(filename) {
  return Core__Option.flatMap(filename.split(".").pop(), (function (ext) {
                switch (ext) {
                  case "js" :
                      return "javascript";
                  case "py" :
                      return "python";
                  case "rs" :
                      return "rust";
                  case "ts" :
                      return "typescript";
                  default:
                    return ;
                }
              }));
}

function getLanguage(languageName) {
  switch (languageName) {
    case "javascript" :
        return TreeSitterJavascript;
    case "python" :
        return TreeSitterPython;
    default:
      throw {
            RE_EXN_ID: "Failure",
            _1: "Unsupported language",
            Error: new Error()
          };
  }
}

function getScmQuery(languageName) {
  var scmFilename;
  switch (languageName) {
    case "javascript" :
        scmFilename = "javascript.scm";
        break;
    case "python" :
        scmFilename = "python.scm";
        break;
    default:
      throw {
            RE_EXN_ID: "Failure",
            _1: "Unsupported scm query for language " + languageName,
            Error: new Error()
          };
  }
  return Fs.readFileSync(Path.join("src", "queries", scmFilename), "utf-8");
}

function orElse(o, f) {
  if (o !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(o));
  } else {
    return f();
  }
}

function buildParser(language) {
  var parser = new TreeSitter();
  parser.setLanguage(language);
  return parser;
}

function buildQuery(language, scm) {
  return new TreeSitter.Query(language, scm);
}

function mergeChunks(chunks) {
  var result = [chunks[0]];
  for(var i = 1 ,i_finish = chunks.length; i < i_finish; ++i){
    var prevIndex = result.length - 1 | 0;
    var curr = chunks[i];
    var prev = result[prevIndex];
    if ((prev.endRow + 1 | 0) === curr.startRow) {
      result[prevIndex] = {
        content: prev.content + "\n" + curr.content,
        startRow: prev.startRow,
        endRow: curr.endRow
      };
    } else {
      result.push(curr);
    }
  }
  return result;
}

function getOutline(filename) {
  return Core__Option.map(Core__Option.map(Core__Option.map(Core__Option.flatMap(Core__Option.map(Core__Option.map(orElse(getLanguageName(filename), (function () {
                                        console.log("Unsupported file extension");
                                      })), (function (languageName) {
                                    var language = getLanguage(languageName);
                                    var scm = getScmQuery(languageName);
                                    return [
                                            language,
                                            scm
                                          ];
                                  })), (function (param) {
                                var language = param[0];
                                var parser = buildParser(language);
                                var query = new TreeSitter.Query(language, param[1]);
                                return [
                                        parser,
                                        query
                                      ];
                              })), (function (param) {
                            try {
                              var source = Fs.readFileSync(filename, "utf-8").trim();
                              if (source === "") {
                                console.log("Empty file: " + filename);
                                return ;
                              }
                              var tree = param[0].parse(source);
                              return [
                                      source,
                                      tree,
                                      param[1]
                                    ];
                            }
                            catch (exn){
                              console.log("Failed to read file: " + filename);
                              return ;
                            }
                          })), (function (param) {
                        var captures = param[2].captures(param[1].rootNode).toSorted(function (a, b) {
                                return a.node.startPosition.row - b.node.startPosition.row | 0;
                              }).filter(function (capture) {
                              var name = capture.name;
                              if (name.startsWith("name.definition.")) {
                                return true;
                              } else {
                                return name.startsWith("name.reference.");
                              }
                            });
                        return [
                                param[0],
                                captures
                              ];
                      })), (function (param) {
                    var lines = param[0].split("\n");
                    return param[1].map(function (capture) {
                                var content = lines.slice(capture.node.startPosition.row, capture.node.endPosition.row + 1 | 0).join("\n");
                                return {
                                        content: content,
                                        startRow: capture.node.startPosition.row,
                                        endRow: capture.node.endPosition.row
                                      };
                              });
                  })), (function (chunks) {
                var merged = mergeChunks(chunks);
                return merged.map(function (chunk) {
                              return chunk.content;
                            }).join("\nâ€¦\n");
              }));
}

var outline = getOutline("/home/akiwu/Projects/wuminzhe/subnames-tools/nameToAddr.js");

console.log(outline);

export {
  getLanguageName ,
  getLanguage ,
  getScmQuery ,
  orElse ,
  buildParser ,
  buildQuery ,
  mergeChunks ,
  getOutline ,
  outline ,
}
/* outline Not a pure module */
