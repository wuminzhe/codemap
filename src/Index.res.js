// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/src/Core__Array.res.js");
var TreeSitter = require("tree-sitter");
var Core__Option = require("@rescript/core/src/Core__Option.res.js");
var TreeSitterPython = require("tree-sitter-python");
var TreeSitterJavascript = require("tree-sitter-javascript");

function getLanguageName(filename) {
  return Core__Option.flatMap(filename.split(".").pop(), (function (ext) {
                switch (ext) {
                  case "js" :
                      return "javascript";
                  case "py" :
                      return "python";
                  case "rs" :
                      return "rust";
                  case "ts" :
                      return "typescript";
                  default:
                    return ;
                }
              }));
}

function getLanguage(languageName) {
  switch (languageName) {
    case "javascript" :
        return TreeSitterJavascript;
    case "python" :
        return TreeSitterPython;
    default:
      throw {
            RE_EXN_ID: "Failure",
            _1: "Unsupported language",
            Error: new Error()
          };
  }
}

function getScmQuery(languageName) {
  var scmFilename;
  switch (languageName) {
    case "javascript" :
        scmFilename = "javascript.scm";
        break;
    case "python" :
        scmFilename = "python.scm";
        break;
    default:
      throw {
            RE_EXN_ID: "Failure",
            _1: "Unsupported scm query for language " + languageName,
            Error: new Error()
          };
  }
  return Fs.readFileSync(scmFilename, "utf-8");
}

function orElse(o, f) {
  if (o !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(o));
  } else {
    return f();
  }
}

function buildParser(language) {
  var parser = new TreeSitter();
  parser.setLanguage(language);
  return parser;
}

function buildQuery(language, scm) {
  return new TreeSitter.Query(language, scm);
}

function getTags(captures) {
  return Core__Array.filterMap(captures, (function (capture) {
                var node = capture.node;
                var name = capture.name;
                var kind = name.startsWith("name.definition.") ? "def" : (
                    name.startsWith("name.reference.") ? "ref" : undefined
                  );
                return Core__Option.map(kind, (function (k) {
                              return {
                                      name: node.text,
                                      kind: k,
                                      line: node.startPosition.row,
                                      col: node.startPosition.column
                                    };
                            }));
              }));
}

function mergeChunks(chunks) {
  var result = [chunks[0]];
  for(var i = 1 ,i_finish = chunks.length; i < i_finish; ++i){
    var prevIndex = result.length - 1 | 0;
    var curr = chunks[i];
    var prev = result[prevIndex];
    if ((prev.endRow + 1 | 0) === curr.startRow) {
      result[prevIndex] = {
        content: prev.content + "\n" + curr.content,
        startRow: prev.startRow,
        endRow: curr.endRow
      };
    } else {
      result.push(curr);
    }
  }
  return result;
}

function getOutline(filename) {
  return Core__Option.map(Core__Option.map(Core__Option.map(Core__Option.map(Core__Option.map(Core__Option.map(orElse(getLanguageName(filename), (function () {
                                        console.log("Unsupported file extension");
                                      })), (function (languageName) {
                                    var language = getLanguage(languageName);
                                    var scm = getScmQuery(languageName);
                                    return [
                                            language,
                                            scm
                                          ];
                                  })), (function (param) {
                                var language = param[0];
                                var parser = buildParser(language);
                                var query = new TreeSitter.Query(language, param[1]);
                                return [
                                        parser,
                                        query
                                      ];
                              })), (function (param) {
                            var source = Fs.readFileSync(filename, "utf-8");
                            var tree = param[0].parse(source);
                            return [
                                    source,
                                    tree,
                                    param[1]
                                  ];
                          })), (function (param) {
                        var captures = param[2].captures(param[1].rootNode).toSorted(function (a, b) {
                                return a.node.startPosition.row - b.node.startPosition.row | 0;
                              }).filter(function (capture) {
                              var name = capture.name;
                              if (name.startsWith("name.definition.")) {
                                return true;
                              } else {
                                return name.startsWith("name.reference.");
                              }
                            });
                        return [
                                param[0],
                                captures
                              ];
                      })), (function (param) {
                    var lines = param[0].split("\n");
                    return param[1].map(function (capture) {
                                var content = lines.slice(capture.node.startPosition.row, capture.node.endPosition.row + 1 | 0).join("\n");
                                return {
                                        content: content,
                                        startRow: capture.node.startPosition.row,
                                        endRow: capture.node.endPosition.row
                                      };
                              });
                  })), (function (chunks) {
                var merged = mergeChunks(chunks);
                return merged.map(function (chunk) {
                              return chunk.content;
                            }).join("\nâ€¦\n");
              }));
}

var outline = getOutline("test.py");

console.log(outline);

exports.getLanguageName = getLanguageName;
exports.getLanguage = getLanguage;
exports.getScmQuery = getScmQuery;
exports.orElse = orElse;
exports.buildParser = buildParser;
exports.buildQuery = buildQuery;
exports.getTags = getTags;
exports.mergeChunks = mergeChunks;
exports.getOutline = getOutline;
exports.outline = outline;
/* outline Not a pure module */
